package aggregategenerator

import (
	"fmt"
	"io"
	"text/template"
	"time"
	"unicode"
)

var NowFunc = time.Now

// Write generates the boilerplate aggregate Go code required for the cqrs package.
func Write(out io.Writer, pkg, aggregateName string, commands, events []string) error {
	if len(commands)+len(events) < 1 {
		return fmt.Errorf("no commands or events found")
	}

	return fileTemplate.Execute(out, templateData{
		Timestamp:     NowFunc(),
		Commands:      commands,
		Events:        events,
		AggregateName: aggregateName,
		Package:       pkg,
	})
}

type templateData struct {
	Timestamp     time.Time
	Commands      []string
	Events        []string
	AggregateName string
	Package       string
}

func lcFirst(str string) string {
	for i, v := range str {
		return string(unicode.ToLower(v)) + str[i+1:]
	}
	return ""
}

var funcMap = template.FuncMap{
	"LcFirst": lcFirst,
}

var fileTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at
// {{ .Timestamp }}
package {{ $.Package }}

import (
	"github.com/inklabs/rangedb"
	"github.com/inklabs/rangedb/pkg/cqrs"
)

func (a *{{ .AggregateName }}) Load(recordIterator rangedb.RecordIterator) {
	for recordIterator.Next() {
{{- if .Events }}
		if recordIterator.Err() == nil {
			if event, ok := recordIterator.Record().Data.(rangedb.Event); ok {
				a.apply(event)
			}
		}
{{- end }}
	}
}

{{- if .Events }}

func (a *{{ .AggregateName }}) apply(event rangedb.Event) {
	switch e := event.(type) {
{{- range .Events }}

	case {{ . }}:
		a.{{ . | LcFirst }}(e)

	case *{{ . }}:
		a.{{ . | LcFirst }}(*e)
{{- end }}

	}
}
{{- end }}

func (a *{{ .AggregateName }}) Handle(command cqrs.Command) []rangedb.Event {
{{- if .Commands }}
	switch c := command.(type) {
{{- range .Commands }}

	case {{ . }}:
		a.{{ . | LcFirst }}(c)

	case *{{ . }}:
		a.{{ . | LcFirst }}(*c)
{{- end }}

	}
{{ end }}
	defer a.resetPendingEvents()
	return a.pendingEvents
}

func (a *{{ .AggregateName }}) resetPendingEvents() {
	a.pendingEvents = nil
}

func (a *{{ .AggregateName }}) CommandTypes() []string {
	return []string{
{{- range .Commands }}
		{{ . }}{}.CommandType(),
{{- end }}
	}
}

func (a *{{ .AggregateName }}) raise(events ...rangedb.Event) {
	a.pendingEvents = append(a.pendingEvents, events...)
}
`))
